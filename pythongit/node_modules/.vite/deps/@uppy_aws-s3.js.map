{
  "version": 3,
  "sources": ["../../retry/lib/retry_operation.js", "../../retry/lib/retry.js", "../../retry/index.js", "../../p-retry/index.js", "../../is-network-error/index.js", "../../@uppy/companion-client/package.json", "../../@uppy/companion-client/lib/AuthError.js", "../../@uppy/companion-client/lib/RequestClient.js", "../../@uppy/aws-s3/package.json", "../../@uppy/aws-s3/lib/createSignedURL.js", "../../@uppy/aws-s3/lib/MultipartUploader.js", "../../@uppy/aws-s3/lib/utils.js", "../../@uppy/aws-s3/lib/HTTPCommunicationQueue.js", "../../@uppy/aws-s3/lib/index.js"],
  "sourcesContent": ["function RetryOperation(timeouts, options) {\n  // Compatibility for the old (timeouts, retryForever) signature\n  if (typeof options === 'boolean') {\n    options = { forever: options };\n  }\n\n  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));\n  this._timeouts = timeouts;\n  this._options = options || {};\n  this._maxRetryTime = options && options.maxRetryTime || Infinity;\n  this._fn = null;\n  this._errors = [];\n  this._attempts = 1;\n  this._operationTimeout = null;\n  this._operationTimeoutCb = null;\n  this._timeout = null;\n  this._operationStart = null;\n  this._timer = null;\n\n  if (this._options.forever) {\n    this._cachedTimeouts = this._timeouts.slice(0);\n  }\n}\nmodule.exports = RetryOperation;\n\nRetryOperation.prototype.reset = function() {\n  this._attempts = 1;\n  this._timeouts = this._originalTimeouts.slice(0);\n}\n\nRetryOperation.prototype.stop = function() {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n  if (this._timer) {\n    clearTimeout(this._timer);\n  }\n\n  this._timeouts       = [];\n  this._cachedTimeouts = null;\n};\n\nRetryOperation.prototype.retry = function(err) {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  if (!err) {\n    return false;\n  }\n  var currentTime = new Date().getTime();\n  if (err && currentTime - this._operationStart >= this._maxRetryTime) {\n    this._errors.push(err);\n    this._errors.unshift(new Error('RetryOperation timeout occurred'));\n    return false;\n  }\n\n  this._errors.push(err);\n\n  var timeout = this._timeouts.shift();\n  if (timeout === undefined) {\n    if (this._cachedTimeouts) {\n      // retry forever, only keep last error\n      this._errors.splice(0, this._errors.length - 1);\n      timeout = this._cachedTimeouts.slice(-1);\n    } else {\n      return false;\n    }\n  }\n\n  var self = this;\n  this._timer = setTimeout(function() {\n    self._attempts++;\n\n    if (self._operationTimeoutCb) {\n      self._timeout = setTimeout(function() {\n        self._operationTimeoutCb(self._attempts);\n      }, self._operationTimeout);\n\n      if (self._options.unref) {\n          self._timeout.unref();\n      }\n    }\n\n    self._fn(self._attempts);\n  }, timeout);\n\n  if (this._options.unref) {\n      this._timer.unref();\n  }\n\n  return true;\n};\n\nRetryOperation.prototype.attempt = function(fn, timeoutOps) {\n  this._fn = fn;\n\n  if (timeoutOps) {\n    if (timeoutOps.timeout) {\n      this._operationTimeout = timeoutOps.timeout;\n    }\n    if (timeoutOps.cb) {\n      this._operationTimeoutCb = timeoutOps.cb;\n    }\n  }\n\n  var self = this;\n  if (this._operationTimeoutCb) {\n    this._timeout = setTimeout(function() {\n      self._operationTimeoutCb();\n    }, self._operationTimeout);\n  }\n\n  this._operationStart = new Date().getTime();\n\n  this._fn(this._attempts);\n};\n\nRetryOperation.prototype.try = function(fn) {\n  console.log('Using RetryOperation.try() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = function(fn) {\n  console.log('Using RetryOperation.start() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = RetryOperation.prototype.try;\n\nRetryOperation.prototype.errors = function() {\n  return this._errors;\n};\n\nRetryOperation.prototype.attempts = function() {\n  return this._attempts;\n};\n\nRetryOperation.prototype.mainError = function() {\n  if (this._errors.length === 0) {\n    return null;\n  }\n\n  var counts = {};\n  var mainError = null;\n  var mainErrorCount = 0;\n\n  for (var i = 0; i < this._errors.length; i++) {\n    var error = this._errors[i];\n    var message = error.message;\n    var count = (counts[message] || 0) + 1;\n\n    counts[message] = count;\n\n    if (count >= mainErrorCount) {\n      mainError = error;\n      mainErrorCount = count;\n    }\n  }\n\n  return mainError;\n};\n", "var RetryOperation = require('./retry_operation');\n\nexports.operation = function(options) {\n  var timeouts = exports.timeouts(options);\n  return new RetryOperation(timeouts, {\n      forever: options && (options.forever || options.retries === Infinity),\n      unref: options && options.unref,\n      maxRetryTime: options && options.maxRetryTime\n  });\n};\n\nexports.timeouts = function(options) {\n  if (options instanceof Array) {\n    return [].concat(options);\n  }\n\n  var opts = {\n    retries: 10,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: Infinity,\n    randomize: false\n  };\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n\n  if (opts.minTimeout > opts.maxTimeout) {\n    throw new Error('minTimeout is greater than maxTimeout');\n  }\n\n  var timeouts = [];\n  for (var i = 0; i < opts.retries; i++) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  if (options && options.forever && !timeouts.length) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  // sort the array numerically ascending\n  timeouts.sort(function(a,b) {\n    return a - b;\n  });\n\n  return timeouts;\n};\n\nexports.createTimeout = function(attempt, opts) {\n  var random = (opts.randomize)\n    ? (Math.random() + 1)\n    : 1;\n\n  var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));\n  timeout = Math.min(timeout, opts.maxTimeout);\n\n  return timeout;\n};\n\nexports.wrap = function(obj, options, methods) {\n  if (options instanceof Array) {\n    methods = options;\n    options = null;\n  }\n\n  if (!methods) {\n    methods = [];\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        methods.push(key);\n      }\n    }\n  }\n\n  for (var i = 0; i < methods.length; i++) {\n    var method   = methods[i];\n    var original = obj[method];\n\n    obj[method] = function retryWrapper(original) {\n      var op       = exports.operation(options);\n      var args     = Array.prototype.slice.call(arguments, 1);\n      var callback = args.pop();\n\n      args.push(function(err) {\n        if (op.retry(err)) {\n          return;\n        }\n        if (err) {\n          arguments[0] = op.mainError();\n        }\n        callback.apply(this, arguments);\n      });\n\n      op.attempt(function() {\n        original.apply(obj, args);\n      });\n    }.bind(obj, original);\n    obj[method].options = options;\n  }\n};\n", "module.exports = require('./lib/retry');", "import retry from 'retry';\nimport isNetworkError from 'is-network-error';\n\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\n\t\tif (message instanceof Error) {\n\t\t\tthis.originalError = message;\n\t\t\t({message} = message);\n\t\t} else {\n\t\t\tthis.originalError = new Error(message);\n\t\t\tthis.originalError.stack = this.stack;\n\t\t}\n\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\nconst decorateErrorWithCounts = (error, attemptNumber, options) => {\n\t// Minus 1 from attemptNumber because the first attempt does not count as a retry\n\tconst retriesLeft = options.retries - (attemptNumber - 1);\n\n\terror.attemptNumber = attemptNumber;\n\terror.retriesLeft = retriesLeft;\n\treturn error;\n};\n\nexport default async function pRetry(input, options) {\n\treturn new Promise((resolve, reject) => {\n\t\toptions = {...options};\n\t\toptions.onFailedAttempt ??= () => {};\n\t\toptions.shouldRetry ??= () => true;\n\t\toptions.retries ??= 10;\n\n\t\tconst operation = retry.operation(options);\n\n\t\tconst abortHandler = () => {\n\t\t\toperation.stop();\n\t\t\treject(options.signal?.reason);\n\t\t};\n\n\t\tif (options.signal && !options.signal.aborted) {\n\t\t\toptions.signal.addEventListener('abort', abortHandler, {once: true});\n\t\t}\n\n\t\tconst cleanUp = () => {\n\t\t\toptions.signal?.removeEventListener('abort', abortHandler);\n\t\t\toperation.stop();\n\t\t};\n\n\t\toperation.attempt(async attemptNumber => {\n\t\t\ttry {\n\t\t\t\tconst result = await input(attemptNumber);\n\t\t\t\tcleanUp();\n\t\t\t\tresolve(result);\n\t\t\t} catch (error) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!(error instanceof Error)) {\n\t\t\t\t\t\tthrow new TypeError(`Non-error was thrown: \"${error}\". You should only throw errors.`);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (error instanceof AbortError) {\n\t\t\t\t\t\tthrow error.originalError;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (error instanceof TypeError && !isNetworkError(error)) {\n\t\t\t\t\t\tthrow error;\n\t\t\t\t\t}\n\n\t\t\t\t\tdecorateErrorWithCounts(error, attemptNumber, options);\n\n\t\t\t\t\tif (!(await options.shouldRetry(error))) {\n\t\t\t\t\t\toperation.stop();\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\n\t\t\t\t\tawait options.onFailedAttempt(error);\n\n\t\t\t\t\tif (!operation.retry(error)) {\n\t\t\t\t\t\tthrow operation.mainError();\n\t\t\t\t\t}\n\t\t\t\t} catch (finalError) {\n\t\t\t\t\tdecorateErrorWithCounts(finalError, attemptNumber, options);\n\t\t\t\t\tcleanUp();\n\t\t\t\t\treject(finalError);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n", "const objectToString = Object.prototype.toString;\n\nconst isError = value => objectToString.call(value) === '[object Error]';\n\nconst errorMessages = new Set([\n\t'network error', // Chrome\n\t'Failed to fetch', // Chrome\n\t'NetworkError when attempting to fetch resource.', // Firefox\n\t'The Internet connection appears to be offline.', // Safari 16\n\t'Network request failed', // `cross-fetch`\n\t'fetch failed', // Undici (Node.js)\n\t'terminated', // Undici (Node.js)\n\t' A network error occurred.', // Bun (WebKit)\n\t'Network connection lost', // Cloudflare Workers (fetch)\n]);\n\nexport default function isNetworkError(error) {\n\tconst isValid = error\n\t\t&& isError(error)\n\t\t&& error.name === 'TypeError'\n\t\t&& typeof error.message === 'string';\n\n\tif (!isValid) {\n\t\treturn false;\n\t}\n\n\tconst {message, stack} = error;\n\n\t// Safari 17+ has generic message but no stack for network errors\n\tif (message === 'Load failed') {\n\t\treturn stack === undefined\n\t\t\t// Sentry adds its own stack trace to the fetch error, so also check for that\n\t\t\t|| '__sentry_captured__' in error;\n\t}\n\n\t// Deno network errors start with specific text\n\tif (message.startsWith('error sending request for url')) {\n\t\treturn true;\n\t}\n\n\t// Standard network error messages\n\treturn errorMessages.has(message);\n}\n", "{\n  \"name\": \"@uppy/companion-client\",\n  \"description\": \"Client library for communication with Companion. Intended for use in Uppy plugins.\",\n  \"version\": \"5.1.0\",\n  \"license\": \"MIT\",\n  \"type\": \"module\",\n  \"sideEffects\": false,\n  \"scripts\": {\n    \"build\": \"tsc --build tsconfig.build.json\",\n    \"typecheck\": \"tsc --build\",\n    \"test\": \"vitest run --environment=jsdom --silent='passed-only'\"\n  },\n  \"keywords\": [\n    \"file uploader\",\n    \"uppy\",\n    \"uppy-plugin\",\n    \"companion\",\n    \"provider\"\n  ],\n  \"homepage\": \"https://uppy.io\",\n  \"bugs\": {\n    \"url\": \"https://github.com/transloadit/uppy/issues\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/transloadit/uppy.git\"\n  },\n  \"files\": [\n    \"src\",\n    \"lib\",\n    \"dist\",\n    \"CHANGELOG.md\"\n  ],\n  \"exports\": {\n    \".\": \"./lib/index.js\",\n    \"./package.json\": \"./package.json\"\n  },\n  \"dependencies\": {\n    \"@uppy/utils\": \"^7.1.0\",\n    \"namespace-emitter\": \"^2.0.1\",\n    \"p-retry\": \"^6.1.0\"\n  },\n  \"devDependencies\": {\n    \"jsdom\": \"^26.1.0\",\n    \"typescript\": \"^5.8.3\",\n    \"vitest\": \"^3.2.4\"\n  },\n  \"peerDependencies\": {\n    \"@uppy/core\": \"^5.1.0\"\n  }\n}", "class AuthError extends Error {\n    isAuthError;\n    constructor() {\n        super('Authorization required');\n        this.name = 'AuthError';\n        // we use a property because of instanceof is unsafe:\n        // https://github.com/transloadit/uppy/pull/4619#discussion_r1406225982\n        this.isAuthError = true;\n    }\n}\nexport default AuthError;\n", "import { ErrorWithCause, fetchWithNetworkError, getSocketHost, UserFacingApiError, } from '@uppy/utils';\nimport pRetry, { AbortError } from 'p-retry';\nimport packageJson from '../package.json' with { type: 'json' };\nimport AuthError from './AuthError.js';\n// Remove the trailing slash so we can always safely append /xyz.\nfunction stripSlash(url) {\n    return url.replace(/\\/$/, '');\n}\nconst retryCount = 10; // set to a low number, like 2 to test manual user retries\nconst socketActivityTimeoutMs = 5 * 60 * 1000; // set to a low number like 10000 to test this\nexport const authErrorStatusCode = 401;\nclass HttpError extends Error {\n    statusCode;\n    constructor({ statusCode, message, }) {\n        super(message);\n        this.name = 'HttpError';\n        this.statusCode = statusCode;\n    }\n}\nasync function handleJSONResponse(res) {\n    if (res.status === authErrorStatusCode) {\n        throw new AuthError();\n    }\n    if (res.ok) {\n        return res.json();\n    }\n    let errMsg = `Failed request with status: ${res.status}. ${res.statusText}`;\n    let errData;\n    try {\n        errData = await res.json();\n        if (errData.message)\n            errMsg = `${errMsg} message: ${errData.message}`;\n        if (errData.requestId)\n            errMsg = `${errMsg} request-Id: ${errData.requestId}`;\n    }\n    catch (cause) {\n        // if the response contains invalid JSON, let's ignore the error data\n        throw new Error(errMsg, { cause });\n    }\n    if (res.status >= 400 && res.status <= 499 && errData.message) {\n        throw new UserFacingApiError(errData.message);\n    }\n    throw new HttpError({ statusCode: res.status, message: errMsg });\n}\nfunction emitSocketProgress(uploader, progressData, file) {\n    const { progress, bytesUploaded, bytesTotal } = progressData;\n    if (progress) {\n        uploader.uppy.log(`Upload progress: ${progress}`);\n        uploader.uppy.emit('upload-progress', file, {\n            uploadStarted: file.progress.uploadStarted ?? 0,\n            bytesUploaded,\n            bytesTotal,\n        });\n    }\n}\nexport default class RequestClient {\n    static VERSION = packageJson.version;\n    #companionHeaders;\n    uppy;\n    opts;\n    constructor(uppy, opts) {\n        this.uppy = uppy;\n        this.opts = opts;\n        this.onReceiveResponse = this.onReceiveResponse.bind(this);\n        this.#companionHeaders = opts.companionHeaders;\n    }\n    setCompanionHeaders(headers) {\n        this.#companionHeaders = headers;\n    }\n    [Symbol.for('uppy test: getCompanionHeaders')]() {\n        return this.#companionHeaders;\n    }\n    get hostname() {\n        const { companion } = this.uppy.getState();\n        const host = this.opts.companionUrl;\n        return stripSlash(companion?.[host] ? companion[host] : host);\n    }\n    async headers(emptyBody = false) {\n        const defaultHeaders = {\n            Accept: 'application/json',\n            ...(emptyBody\n                ? undefined\n                : {\n                    // Passing those headers on requests with no data forces browsers to first make a preflight request.\n                    'Content-Type': 'application/json',\n                }),\n        };\n        return {\n            ...defaultHeaders,\n            ...this.#companionHeaders,\n        };\n    }\n    onReceiveResponse(res) {\n        const { headers } = res;\n        const state = this.uppy.getState();\n        const companion = state.companion || {};\n        const host = this.opts.companionUrl;\n        // Store the self-identified domain name for the Companion instance we just hit.\n        if (headers.has('i-am') && headers.get('i-am') !== companion[host]) {\n            this.uppy.setState({\n                companion: { ...companion, [host]: headers.get('i-am') },\n            });\n        }\n    }\n    #getUrl(url) {\n        if (/^(https?:|)\\/\\//.test(url)) {\n            return url;\n        }\n        return `${this.hostname}/${url}`;\n    }\n    async request({ path, method = 'GET', data, skipPostResponse, signal, }) {\n        try {\n            const headers = await this.headers(!data);\n            const response = await fetchWithNetworkError(this.#getUrl(path), {\n                method,\n                signal,\n                headers,\n                credentials: this.opts.companionCookiesRule || 'same-origin',\n                body: data ? JSON.stringify(data) : null,\n            });\n            if (!skipPostResponse)\n                this.onReceiveResponse(response);\n            return await handleJSONResponse(response);\n        }\n        catch (err) {\n            // pass these through\n            if (err.isAuthError ||\n                err.name === 'UserFacingApiError' ||\n                err.name === 'AbortError')\n                throw err;\n            throw new ErrorWithCause(`Could not ${method} ${this.#getUrl(path)}`, {\n                cause: err,\n            });\n        }\n    }\n    async get(path, options) {\n        return this.request({ ...options, path });\n    }\n    async post(path, data, options) {\n        return this.request({ ...options, path, method: 'POST', data });\n    }\n    async delete(path, data, options) {\n        return this.request({ ...options, path, method: 'DELETE', data });\n    }\n    /**\n     * Remote uploading consists of two steps:\n     * 1. #requestSocketToken which starts the download/upload in companion and returns a unique token for the upload.\n     * Then companion will halt the upload until:\n     * 2. #awaitRemoteFileUpload is called, which will open/ensure a websocket connection towards companion, with the\n     * previously generated token provided. It returns a promise that will resolve/reject once the file has finished\n     * uploading or is otherwise done (failed, canceled)\n     */\n    async uploadRemoteFile(file, reqBody, options) {\n        try {\n            const { signal, getQueue } = options || {};\n            return await pRetry(async () => {\n                // if we already have a serverToken, assume that we are resuming the existing server upload id\n                const existingServerToken = this.uppy.getFile(file.id)?.serverToken;\n                if (existingServerToken != null) {\n                    this.uppy.log(`Connecting to exiting websocket ${existingServerToken}`);\n                    return this.#awaitRemoteFileUpload({\n                        file,\n                        queue: getQueue(),\n                        signal,\n                    });\n                }\n                const queueRequestSocketToken = getQueue().wrapPromiseFunction(async (...args) => {\n                    try {\n                        return await this.#requestSocketToken(...args);\n                    }\n                    catch (outerErr) {\n                        // throwing AbortError will cause p-retry to stop retrying\n                        if (outerErr.isAuthError)\n                            throw new AbortError(outerErr);\n                        if (outerErr.cause == null)\n                            throw outerErr;\n                        const err = outerErr.cause;\n                        const isRetryableHttpError = () => [408, 409, 429, 418, 423].includes(err.statusCode) ||\n                            (err.statusCode >= 500 &&\n                                err.statusCode <= 599 &&\n                                ![501, 505].includes(err.statusCode));\n                        if (err.name === 'HttpError' && !isRetryableHttpError())\n                            throw new AbortError(err);\n                        // p-retry will retry most other errors,\n                        // but it will not retry TypeError (except network error TypeErrors)\n                        throw err;\n                    }\n                }, { priority: -1 });\n                const serverToken = await queueRequestSocketToken({\n                    file,\n                    postBody: reqBody,\n                    signal,\n                }).abortOn(signal);\n                if (!this.uppy.getFile(file.id))\n                    return undefined; // has file since been removed?\n                this.uppy.setFileState(file.id, { serverToken });\n                return this.#awaitRemoteFileUpload({\n                    file: this.uppy.getFile(file.id), // re-fetching file because it might have changed in the meantime\n                    queue: getQueue(),\n                    signal,\n                });\n            }, {\n                retries: retryCount,\n                signal,\n                onFailedAttempt: (err) => this.uppy.log(`Retrying upload due to: ${err.message}`, 'warning'),\n            });\n        }\n        catch (err) {\n            // this is a bit confusing, but note that an error with the `name` prop set to 'AbortError' (from AbortController)\n            // is not the same as `p-retry` `AbortError`\n            if (err.name === 'AbortError') {\n                // The file upload was aborted, it’s not an error\n                return undefined;\n            }\n            this.uppy.emit('upload-error', file, err);\n            throw err;\n        }\n    }\n    #requestSocketToken = async ({ file, postBody, signal, }) => {\n        if (file.remote?.url == null) {\n            throw new Error('Cannot connect to an undefined URL');\n        }\n        const res = await this.post(file.remote.url, {\n            ...file.remote.body,\n            ...postBody,\n        }, { signal });\n        return res.token;\n    };\n    /**\n     * This method will ensure a websocket for the specified file and returns a promise that resolves\n     * when the file has finished downloading, or rejects if it fails.\n     * It will retry if the websocket gets disconnected\n     */\n    async #awaitRemoteFileUpload({ file, queue, signal, }) {\n        let removeEventHandlers;\n        const { capabilities } = this.uppy.getState();\n        try {\n            return await new Promise((resolve, reject) => {\n                const token = file.serverToken;\n                const host = getSocketHost(file.remote.companionUrl);\n                let socket;\n                let socketAbortController;\n                let activityTimeout;\n                let { isPaused } = file;\n                const socketSend = (action, payload) => {\n                    if (socket == null || socket.readyState !== socket.OPEN) {\n                        this.uppy.log(`Cannot send \"${action}\" to socket ${file.id} because the socket state was ${String(socket?.readyState)}`, 'warning');\n                        return;\n                    }\n                    socket.send(JSON.stringify({\n                        action,\n                        payload: payload ?? {},\n                    }));\n                };\n                function sendState() {\n                    if (!capabilities.resumableUploads)\n                        return;\n                    if (isPaused)\n                        socketSend('pause');\n                    else\n                        socketSend('resume');\n                }\n                const createWebsocket = async () => {\n                    if (socketAbortController)\n                        socketAbortController.abort();\n                    socketAbortController = new AbortController();\n                    const onFatalError = (err) => {\n                        // Remove the serverToken so that a new one will be created for the retry.\n                        this.uppy.setFileState(file.id, { serverToken: null });\n                        socketAbortController?.abort?.();\n                        reject(err);\n                    };\n                    // todo instead implement the ability for users to cancel / retry *currently uploading files* in the UI\n                    function resetActivityTimeout() {\n                        clearTimeout(activityTimeout);\n                        if (isPaused)\n                            return;\n                        activityTimeout = setTimeout(() => onFatalError(new Error('Timeout waiting for message from Companion socket')), socketActivityTimeoutMs);\n                    }\n                    try {\n                        await queue\n                            .wrapPromiseFunction(async () => {\n                            const reconnectWebsocket = async () => new Promise((_, rejectSocket) => {\n                                socket = new WebSocket(`${host}/api/${token}`);\n                                resetActivityTimeout();\n                                socket.addEventListener('close', () => {\n                                    socket = undefined;\n                                    rejectSocket(new Error('Socket closed unexpectedly'));\n                                });\n                                socket.addEventListener('error', (error) => {\n                                    this.uppy.log(`Companion socket error ${JSON.stringify(error)}, closing socket`, 'warning');\n                                    socket?.close(); // will 'close' event to be emitted\n                                });\n                                socket.addEventListener('open', () => {\n                                    sendState();\n                                });\n                                socket.addEventListener('message', (e) => {\n                                    resetActivityTimeout();\n                                    try {\n                                        const { action, payload } = JSON.parse(e.data);\n                                        switch (action) {\n                                            case 'progress': {\n                                                emitSocketProgress(this, payload, this.uppy.getFile(file.id));\n                                                break;\n                                            }\n                                            case 'success': {\n                                                // payload.response is sent from companion for xhr-upload (aka uploadMultipart in companion) and\n                                                // s3 multipart (aka uploadS3Multipart)\n                                                // but not for tus/transloadit (aka uploadTus)\n                                                // responseText is a string which may or may not be in JSON format\n                                                // this means that an upload destination of xhr or s3 multipart MUST respond with valid JSON\n                                                // to companion, or the JSON.parse will crash\n                                                const text = payload.response?.responseText;\n                                                this.uppy.emit('upload-success', this.uppy.getFile(file.id), {\n                                                    uploadURL: payload.url,\n                                                    status: payload.response?.status ?? 200,\n                                                    body: text\n                                                        ? JSON.parse(text)\n                                                        : undefined,\n                                                });\n                                                socketAbortController?.abort?.();\n                                                resolve();\n                                                break;\n                                            }\n                                            case 'error': {\n                                                const { message } = payload.error;\n                                                throw Object.assign(new Error(message), {\n                                                    cause: payload.error,\n                                                });\n                                            }\n                                            default:\n                                                this.uppy.log(`Companion socket unknown action ${action}`, 'warning');\n                                        }\n                                    }\n                                    catch (err) {\n                                        onFatalError(err);\n                                    }\n                                });\n                                const closeSocket = () => {\n                                    this.uppy.log(`Closing socket ${file.id}`);\n                                    clearTimeout(activityTimeout);\n                                    if (socket)\n                                        socket.close();\n                                    socket = undefined;\n                                };\n                                socketAbortController.signal.addEventListener('abort', () => {\n                                    closeSocket();\n                                });\n                            });\n                            await pRetry(reconnectWebsocket, {\n                                retries: retryCount,\n                                signal: socketAbortController.signal,\n                                onFailedAttempt: () => {\n                                    if (socketAbortController.signal.aborted)\n                                        return; // don't log in this case\n                                    this.uppy.log(`Retrying websocket ${file.id}`);\n                                },\n                            });\n                        })()\n                            .abortOn(socketAbortController.signal);\n                    }\n                    catch (err) {\n                        if (socketAbortController.signal.aborted)\n                            return;\n                        onFatalError(err);\n                    }\n                };\n                const pause = (newPausedState) => {\n                    if (!capabilities.resumableUploads)\n                        return;\n                    isPaused = newPausedState;\n                    if (socket)\n                        sendState();\n                };\n                const onFileRemove = (targetFile) => {\n                    if (!capabilities.individualCancellation)\n                        return;\n                    if (targetFile.id !== file.id)\n                        return;\n                    socketSend('cancel');\n                    socketAbortController?.abort?.();\n                    this.uppy.log(`upload ${file.id} was removed`);\n                    resolve();\n                };\n                const onCancelAll = () => {\n                    socketSend('cancel');\n                    socketAbortController?.abort?.();\n                    this.uppy.log(`upload ${file.id} was canceled`);\n                    resolve();\n                };\n                const onFilePausedChange = (targetFile, newPausedState) => {\n                    if (targetFile?.id !== file.id)\n                        return;\n                    pause(newPausedState);\n                };\n                const onPauseAll = () => pause(true);\n                const onResumeAll = () => pause(false);\n                this.uppy.on('file-removed', onFileRemove);\n                this.uppy.on('cancel-all', onCancelAll);\n                this.uppy.on('upload-pause', onFilePausedChange);\n                this.uppy.on('pause-all', onPauseAll);\n                this.uppy.on('resume-all', onResumeAll);\n                removeEventHandlers = () => {\n                    this.uppy.off('file-removed', onFileRemove);\n                    this.uppy.off('cancel-all', onCancelAll);\n                    this.uppy.off('upload-pause', onFilePausedChange);\n                    this.uppy.off('pause-all', onPauseAll);\n                    this.uppy.off('resume-all', onResumeAll);\n                };\n                signal.addEventListener('abort', () => {\n                    socketAbortController?.abort();\n                });\n                createWebsocket();\n            });\n        }\n        finally {\n            // @ts-expect-error used before defined\n            removeEventHandlers?.();\n        }\n    }\n}\n", "{\n  \"name\": \"@uppy/aws-s3\",\n  \"description\": \"Upload to Amazon S3 with Uppy\",\n  \"version\": \"5.0.1\",\n  \"license\": \"MIT\",\n  \"type\": \"module\",\n  \"sideEffects\": false,\n  \"scripts\": {\n    \"build\": \"tsc --build tsconfig.build.json\",\n    \"typecheck\": \"tsc --build\",\n    \"test\": \"vitest run --environment=jsdom --silent='passed-only'\"\n  },\n  \"keywords\": [\n    \"file uploader\",\n    \"aws s3\",\n    \"amazon s3\",\n    \"s3\",\n    \"uppy\",\n    \"uppy-plugin\",\n    \"multipart\"\n  ],\n  \"homepage\": \"https://uppy.io\",\n  \"bugs\": {\n    \"url\": \"https://github.com/transloadit/uppy/issues\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/transloadit/uppy.git\"\n  },\n  \"files\": [\n    \"src\",\n    \"lib\",\n    \"dist\",\n    \"CHANGELOG.md\"\n  ],\n  \"exports\": {\n    \".\": \"./lib/index.js\",\n    \"./package.json\": \"./package.json\"\n  },\n  \"dependencies\": {\n    \"@uppy/companion-client\": \"^5.0.1\",\n    \"@uppy/utils\": \"^7.0.2\"\n  },\n  \"devDependencies\": {\n    \"@aws-sdk/client-s3\": \"^3.362.0\",\n    \"@aws-sdk/s3-request-presigner\": \"^3.362.0\",\n    \"@uppy/core\": \"^5.0.2\",\n    \"jsdom\": \"^26.1.0\",\n    \"nock\": \"^13.1.0\",\n    \"typescript\": \"^5.8.3\",\n    \"vitest\": \"^3.2.4\",\n    \"whatwg-fetch\": \"3.6.2\"\n  },\n  \"peerDependencies\": {\n    \"@uppy/core\": \"^5.0.2\"\n  }\n}", "/**\n * Create a canonical request by concatenating the following strings, separated\n * by newline characters. This helps ensure that the signature that you\n * calculate and the signature that AWS calculates can match.\n *\n * @see https://docs.aws.amazon.com/IAM/latest/UserGuide/create-signed-request.html#create-canonical-request\n *\n * @param param0\n * @param param0.method – The HTTP method.\n * @param param0.CanonicalUri – The URI-encoded version of the absolute\n * path component URL (everything between the host and the question mark\n * character (?) that starts the query string parameters). If the absolute path\n * is empty, use a forward slash character (/).\n * @param param0.CanonicalQueryString – The URL-encoded query string\n * parameters, separated by ampersands (&). Percent-encode reserved characters,\n * including the space character. Encode names and values separately. If there\n * are empty parameters, append the equals sign to the parameter name before\n * encoding. After encoding, sort the parameters alphabetically by key name. If\n * there is no query string, use an empty string (\"\").\n * @param param0.SignedHeaders – The request headers,\n * that will be signed, and their values, separated by newline characters.\n * For the values, trim any leading or trailing spaces, convert sequential\n * spaces to a single space, and separate the values for a multi-value header\n * using commas. You must include the host header (HTTP/1.1), and any x-amz-*\n * headers in the signature. You can optionally include other standard headers\n * in the signature, such as content-type.\n * @param param0.HashedPayload – A string created using the payload in\n * the body of the HTTP request as input to a hash function. This string uses\n * lowercase hexadecimal characters. If the payload is empty, use an empty\n * string as the input to the hash function.\n */\nfunction createCanonicalRequest({ method = 'PUT', CanonicalUri = '/', CanonicalQueryString = '', SignedHeaders, HashedPayload, }) {\n    const headerKeys = Object.keys(SignedHeaders)\n        .map((k) => k.toLowerCase())\n        .sort();\n    return [\n        method,\n        CanonicalUri,\n        CanonicalQueryString,\n        ...headerKeys.map((k) => `${k}:${SignedHeaders[k]}`),\n        '',\n        headerKeys.join(';'),\n        HashedPayload,\n    ].join('\\n');\n}\nconst ec = new TextEncoder();\nconst algorithm = { name: 'HMAC', hash: 'SHA-256' };\nasync function digest(data) {\n    const { subtle } = globalThis.crypto;\n    return subtle.digest(algorithm.hash, ec.encode(data));\n}\nasync function generateHmacKey(secret) {\n    const { subtle } = globalThis.crypto;\n    return subtle.importKey('raw', typeof secret === 'string' ? ec.encode(secret) : secret, algorithm, false, ['sign']);\n}\nfunction arrayBufferToHexString(arrayBuffer) {\n    const byteArray = new Uint8Array(arrayBuffer);\n    let hexString = '';\n    for (let i = 0; i < byteArray.length; i++) {\n        hexString += byteArray[i].toString(16).padStart(2, '0');\n    }\n    return hexString;\n}\nasync function hash(key, data) {\n    const { subtle } = globalThis.crypto;\n    return subtle.sign(algorithm, await generateHmacKey(key), ec.encode(data));\n}\n/**\n * @see https://docs.aws.amazon.com/IAM/latest/UserGuide/create-signed-request.html\n */\nexport default async function createSignedURL({ accountKey, accountSecret, sessionToken, bucketName, Key, Region, expires, uploadId, partNumber, }) {\n    const Service = 's3';\n    const host = `${Service}.${Region}.amazonaws.com`;\n    /**\n     * List of char out of `encodeURI()` is taken from ECMAScript spec.\n     * Note that the `/` character is purposefully not included in list below.\n     *\n     * @see https://tc39.es/ecma262/#sec-encodeuri-uri\n     */\n    const CanonicalUri = `/${bucketName}/${encodeURI(Key).replace(/[;?:@&=+$,#!'()*]/g, (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`)}`;\n    const payload = 'UNSIGNED-PAYLOAD';\n    const requestDateTime = new Date().toISOString().replace(/[-:]|\\.\\d+/g, ''); // YYYYMMDDTHHMMSSZ\n    const date = requestDateTime.slice(0, 8); // YYYYMMDD\n    const scope = `${date}/${Region}/${Service}/aws4_request`;\n    const url = new URL(`https://${host}${CanonicalUri}`);\n    // N.B.: URL search params needs to be added in the ASCII order\n    url.searchParams.set('X-Amz-Algorithm', 'AWS4-HMAC-SHA256');\n    url.searchParams.set('X-Amz-Content-Sha256', payload);\n    url.searchParams.set('X-Amz-Credential', `${accountKey}/${scope}`);\n    url.searchParams.set('X-Amz-Date', requestDateTime);\n    url.searchParams.set('X-Amz-Expires', expires);\n    // We are signing on the client, so we expect there's going to be a session token:\n    url.searchParams.set('X-Amz-Security-Token', sessionToken);\n    url.searchParams.set('X-Amz-SignedHeaders', 'host');\n    // Those two are present only for Multipart Uploads:\n    if (partNumber)\n        url.searchParams.set('partNumber', partNumber);\n    if (uploadId)\n        url.searchParams.set('uploadId', uploadId);\n    url.searchParams.set('x-id', partNumber && uploadId ? 'UploadPart' : 'PutObject');\n    // Step 1: Create a canonical request\n    const canonical = createCanonicalRequest({\n        CanonicalUri,\n        CanonicalQueryString: url.search.slice(1),\n        SignedHeaders: {\n            host,\n        },\n        HashedPayload: payload,\n    });\n    // Step 2: Create a hash of the canonical request\n    const hashedCanonical = arrayBufferToHexString(await digest(canonical));\n    // Step 3: Create a string to sign\n    const stringToSign = [\n        `AWS4-HMAC-SHA256`, // The algorithm used to create the hash of the canonical request.\n        requestDateTime, // The date and time used in the credential scope.\n        scope, // The credential scope. This restricts the resulting signature to the specified Region and service.\n        hashedCanonical, // The hash of the canonical request.\n    ].join('\\n');\n    // Step 4: Calculate the signature\n    const kDate = await hash(`AWS4${accountSecret}`, date);\n    const kRegion = await hash(kDate, Region);\n    const kService = await hash(kRegion, Service);\n    const kSigning = await hash(kService, 'aws4_request');\n    const signature = arrayBufferToHexString(await hash(kSigning, stringToSign));\n    // Step 5: Add the signature to the request\n    url.searchParams.set('X-Amz-Signature', signature);\n    return url;\n}\n", "import { AbortController } from '@uppy/utils';\nconst MB = 1024 * 1024;\nconst defaultOptions = {\n    getChunkSize(file) {\n        return Math.ceil(file.size / 10000);\n    },\n    onProgress() { },\n    onPartComplete() { },\n    onSuccess() { },\n    onError(err) {\n        throw err;\n    },\n};\nfunction ensureInt(value) {\n    if (typeof value === 'string') {\n        // @ts-expect-error TS is not able to recognize it's fine.\n        return parseInt(value, 10);\n    }\n    if (typeof value === 'number') {\n        // @ts-expect-error TS is not able to recognize it's fine.\n        return value;\n    }\n    throw new TypeError('Expected a number');\n}\nexport const pausingUploadReason = Symbol('pausing upload, not an actual error');\n/**\n * A MultipartUploader instance is used per file upload to determine whether a\n * upload should be done as multipart or as a regular S3 upload\n * (based on the user-provided `shouldUseMultipart` option value) and to manage\n * the chunk splitting.\n */\nclass MultipartUploader {\n    options;\n    #abortController = new AbortController();\n    #chunks = [];\n    #chunkState = [];\n    /**\n     * The (un-chunked) data to upload.\n     */\n    #data;\n    #file;\n    #uploadHasStarted = false;\n    #onError;\n    #onSuccess;\n    #shouldUseMultipart;\n    #isRestoring;\n    #onReject = (err) => err?.cause === pausingUploadReason ? null : this.#onError(err);\n    #maxMultipartParts = 10_000;\n    #minPartSize = 5 * MB;\n    constructor(data, options) {\n        this.options = {\n            ...defaultOptions,\n            ...options,\n        };\n        // Use default `getChunkSize` if it was null or something\n        this.options.getChunkSize ??= defaultOptions.getChunkSize;\n        this.#data = data;\n        this.#file = options.file;\n        this.#onSuccess = this.options.onSuccess;\n        this.#onError = this.options.onError;\n        this.#shouldUseMultipart = this.options.shouldUseMultipart;\n        // When we are restoring an upload, we already have an UploadId and a Key. Otherwise\n        // we need to call `createMultipartUpload` to get an `uploadId` and a `key`.\n        // Non-multipart uploads are not restorable.\n        this.#isRestoring = (options.uploadId && options.key);\n        this.#initChunks();\n    }\n    // initChunks checks the user preference for using multipart uploads (opts.shouldUseMultipart)\n    // and calculates the optimal part size. When using multipart part uploads every part except for the last has\n    // to be at least 5 MB and there can be no more than 10K parts.\n    // This means we sometimes need to change the preferred part size from the user in order to meet these requirements.\n    #initChunks() {\n        const fileSize = this.#data.size;\n        const shouldUseMultipart = typeof this.#shouldUseMultipart === 'function'\n            ? this.#shouldUseMultipart(this.#file)\n            : Boolean(this.#shouldUseMultipart);\n        if (shouldUseMultipart && fileSize > this.#minPartSize) {\n            // At least 5MB per request:\n            let chunkSize = Math.max(this.options.getChunkSize(this.#data), // Math.max can take undefined but TS does not think so\n            this.#minPartSize);\n            let arraySize = Math.floor(fileSize / chunkSize);\n            // At most 10k requests per file:\n            if (arraySize > this.#maxMultipartParts) {\n                arraySize = this.#maxMultipartParts;\n                chunkSize = fileSize / this.#maxMultipartParts;\n            }\n            this.#chunks = Array(arraySize);\n            for (let offset = 0, j = 0; offset < fileSize; offset += chunkSize, j++) {\n                const end = Math.min(fileSize, offset + chunkSize);\n                // Defer data fetching/slicing until we actually need the data, because it's slow if we have a lot of files\n                const getData = () => {\n                    const i2 = offset;\n                    return this.#data.slice(i2, end);\n                };\n                this.#chunks[j] = {\n                    getData,\n                    onProgress: this.#onPartProgress(j),\n                    onComplete: this.#onPartComplete(j),\n                    shouldUseMultipart,\n                };\n                if (this.#isRestoring) {\n                    const size = offset + chunkSize > fileSize ? fileSize - offset : chunkSize;\n                    // setAsUploaded is called by listPart, to keep up-to-date the\n                    // quantity of data that is left to actually upload.\n                    this.#chunks[j].setAsUploaded = () => {\n                        this.#chunks[j] = null;\n                        this.#chunkState[j].uploaded = size;\n                    };\n                }\n            }\n        }\n        else {\n            this.#chunks = [\n                {\n                    getData: () => this.#data,\n                    onProgress: this.#onPartProgress(0),\n                    onComplete: this.#onPartComplete(0),\n                    shouldUseMultipart,\n                },\n            ];\n        }\n        this.#chunkState = this.#chunks.map(() => ({ uploaded: 0 }));\n    }\n    #createUpload() {\n        this.options.companionComm\n            .uploadFile(this.#file, this.#chunks, this.#abortController.signal)\n            .then(this.#onSuccess, this.#onReject);\n        this.#uploadHasStarted = true;\n    }\n    #resumeUpload() {\n        this.options.companionComm\n            .resumeUploadFile(this.#file, this.#chunks, this.#abortController.signal)\n            .then(this.#onSuccess, this.#onReject);\n    }\n    #onPartProgress = (index) => (ev) => {\n        if (!ev.lengthComputable)\n            return;\n        this.#chunkState[index].uploaded = ensureInt(ev.loaded);\n        const totalUploaded = this.#chunkState.reduce((n, c) => n + c.uploaded, 0);\n        this.options.onProgress(totalUploaded, this.#data.size);\n    };\n    #onPartComplete = (index) => (etag) => {\n        // This avoids the net::ERR_OUT_OF_MEMORY in Chromium Browsers.\n        this.#chunks[index] = null;\n        this.#chunkState[index].etag = etag;\n        this.#chunkState[index].done = true;\n        const part = {\n            PartNumber: index + 1,\n            ETag: etag,\n        };\n        this.options.onPartComplete(part);\n    };\n    #abortUpload() {\n        this.#abortController.abort();\n        this.options.companionComm\n            .abortFileUpload(this.#file)\n            .catch((err) => this.options.log(err));\n    }\n    start() {\n        if (this.#uploadHasStarted) {\n            if (!this.#abortController.signal.aborted)\n                this.#abortController.abort(pausingUploadReason);\n            this.#abortController = new AbortController();\n            this.#resumeUpload();\n        }\n        else if (this.#isRestoring) {\n            this.options.companionComm.restoreUploadFile(this.#file, {\n                uploadId: this.options.uploadId,\n                key: this.options.key,\n            });\n            this.#resumeUpload();\n        }\n        else {\n            this.#createUpload();\n        }\n    }\n    pause() {\n        this.#abortController.abort(pausingUploadReason);\n        // Swap it out for a new controller, because this instance may be resumed later.\n        this.#abortController = new AbortController();\n    }\n    abort(opts) {\n        if (opts?.really)\n            this.#abortUpload();\n        else\n            this.pause();\n    }\n    [Symbol.for('uppy test: getChunkState')]() {\n        return this.#chunkState;\n    }\n}\nexport default MultipartUploader;\n", "import { createAbortError } from '@uppy/utils';\nexport function throwIfAborted(signal) {\n    if (signal?.aborted) {\n        throw createAbortError('The operation was aborted', {\n            cause: signal.reason,\n        });\n    }\n}\n", "import { pausingUploadReason } from './MultipartUploader.js';\nimport { throwIfAborted } from './utils.js';\nfunction removeMetadataFromURL(urlString) {\n    const urlObject = new URL(urlString);\n    urlObject.search = '';\n    urlObject.hash = '';\n    return urlObject.href;\n}\nexport class HTTPCommunicationQueue {\n    #abortMultipartUpload;\n    #cache = new WeakMap();\n    #createMultipartUpload;\n    #fetchSignature;\n    #getUploadParameters;\n    #listParts;\n    #previousRetryDelay;\n    #requests;\n    #retryDelays;\n    #sendCompletionRequest;\n    #setS3MultipartState;\n    #uploadPartBytes;\n    #getFile;\n    constructor(requests, options, setS3MultipartState, getFile) {\n        this.#requests = requests;\n        this.#setS3MultipartState = setS3MultipartState;\n        this.#getFile = getFile;\n        this.setOptions(options);\n    }\n    setOptions(options) {\n        const requests = this.#requests;\n        if ('abortMultipartUpload' in options) {\n            this.#abortMultipartUpload = requests.wrapPromiseFunction(options.abortMultipartUpload, { priority: 1 });\n        }\n        if ('createMultipartUpload' in options) {\n            this.#createMultipartUpload = requests.wrapPromiseFunction(options.createMultipartUpload, { priority: -1 });\n        }\n        if ('signPart' in options) {\n            this.#fetchSignature = requests.wrapPromiseFunction(options.signPart);\n        }\n        if ('listParts' in options) {\n            this.#listParts = requests.wrapPromiseFunction(options.listParts);\n        }\n        if ('completeMultipartUpload' in options) {\n            this.#sendCompletionRequest = requests.wrapPromiseFunction(options.completeMultipartUpload, { priority: 1 });\n        }\n        if ('retryDelays' in options) {\n            this.#retryDelays = options.retryDelays ?? [];\n        }\n        if ('uploadPartBytes' in options) {\n            this.#uploadPartBytes = requests.wrapPromiseFunction(options.uploadPartBytes, { priority: Infinity });\n        }\n        if ('getUploadParameters' in options) {\n            this.#getUploadParameters = requests.wrapPromiseFunction(options.getUploadParameters);\n        }\n    }\n    async #shouldRetry(err, retryDelayIterator) {\n        const requests = this.#requests;\n        const status = err?.source?.status;\n        // TODO: this retry logic is taken out of Tus. We should have a centralized place for retrying,\n        // perhaps the rate limited queue, and dedupe all plugins with that.\n        if (status == null) {\n            return false;\n        }\n        if (status === 403 && err.message === 'Request has expired') {\n            if (!requests.isPaused) {\n                // We don't want to exhaust the retryDelayIterator as long as there are\n                // more than one request in parallel, to give slower connection a chance\n                // to catch up with the expiry set in Companion.\n                if (requests.limit === 1 || this.#previousRetryDelay == null) {\n                    const next = retryDelayIterator.next();\n                    if (next == null || next.done) {\n                        return false;\n                    }\n                    // If there are more than 1 request done in parallel, the RLQ limit is\n                    // decreased and the failed request is requeued after waiting for a bit.\n                    // If there is only one request in parallel, the limit can't be\n                    // decreased, so we iterate over `retryDelayIterator` as we do for\n                    // other failures.\n                    // `#previousRetryDelay` caches the value so we can re-use it next time.\n                    this.#previousRetryDelay = next.value;\n                }\n                // No need to stop the other requests, we just want to lower the limit.\n                requests.rateLimit(0);\n                await new Promise((resolve) => setTimeout(resolve, this.#previousRetryDelay));\n            }\n        }\n        else if (status === 429) {\n            // HTTP 429 Too Many Requests => to avoid the whole download to fail, pause all requests.\n            if (!requests.isPaused) {\n                const next = retryDelayIterator.next();\n                if (next == null || next.done) {\n                    return false;\n                }\n                requests.rateLimit(next.value);\n            }\n        }\n        else if (status > 400 && status < 500 && status !== 409) {\n            // HTTP 4xx, the server won't send anything, it's doesn't make sense to retry\n            return false;\n        }\n        else if (typeof navigator !== 'undefined' && navigator.onLine === false) {\n            // The navigator is offline, let's wait for it to come back online.\n            if (!requests.isPaused) {\n                requests.pause();\n                window.addEventListener('online', () => {\n                    requests.resume();\n                }, { once: true });\n            }\n        }\n        else {\n            // Other error code means the request can be retried later.\n            const next = retryDelayIterator.next();\n            if (next == null || next.done) {\n                return false;\n            }\n            await new Promise((resolve) => setTimeout(resolve, next.value));\n        }\n        return true;\n    }\n    async getUploadId(file, signal) {\n        let cachedResult;\n        // As the cache is updated asynchronously, there could be a race condition\n        // where we just miss a new result so we loop here until we get nothing back,\n        // at which point it's out turn to create a new cache entry.\n        for (;;) {\n            cachedResult = this.#cache.get(file.data);\n            if (cachedResult == null)\n                break;\n            try {\n                return await cachedResult;\n            }\n            catch {\n                // In case of failure, we want to ignore the cached error.\n                // At this point, either there's a new cached value, or we'll exit the loop a create a new one.\n            }\n        }\n        const promise = this.#createMultipartUpload(this.#getFile(file), signal);\n        const abortPromise = () => {\n            promise.abort(signal.reason);\n            this.#cache.delete(file.data);\n        };\n        signal.addEventListener('abort', abortPromise, { once: true });\n        this.#cache.set(file.data, promise);\n        promise.then(async (result) => {\n            signal.removeEventListener('abort', abortPromise);\n            this.#setS3MultipartState(file, result);\n            this.#cache.set(file.data, result);\n        }, () => {\n            signal.removeEventListener('abort', abortPromise);\n            this.#cache.delete(file.data);\n        });\n        return promise;\n    }\n    async abortFileUpload(file) {\n        const result = this.#cache.get(file.data);\n        if (result == null) {\n            // If the createMultipartUpload request never was made, we don't\n            // need to send the abortMultipartUpload request.\n            return;\n        }\n        // Remove the cache entry right away for follow-up requests do not try to\n        // use the soon-to-be aborted cached values.\n        this.#cache.delete(file.data);\n        this.#setS3MultipartState(file, Object.create(null));\n        let awaitedResult;\n        try {\n            awaitedResult = await result;\n        }\n        catch {\n            // If the cached result rejects, there's nothing to abort.\n            return;\n        }\n        await this.#abortMultipartUpload(this.#getFile(file), awaitedResult);\n    }\n    async #nonMultipartUpload(file, chunk, signal) {\n        const { method = 'POST', url, fields, headers, } = await this.#getUploadParameters(this.#getFile(file), {\n            signal,\n        }).abortOn(signal);\n        let body;\n        const data = chunk.getData();\n        if (method.toUpperCase() === 'POST') {\n            const formData = new FormData();\n            Object.entries(fields).forEach(([key, value]) => formData.set(key, value));\n            formData.set('file', data);\n            body = formData;\n        }\n        else {\n            body = data;\n        }\n        const { onProgress, onComplete } = chunk;\n        const result = (await this.#uploadPartBytes({\n            signature: { url, headers, method },\n            body,\n            size: data.size,\n            onProgress,\n            onComplete,\n            signal,\n        }).abortOn(signal)); // todo this doesn't make sense\n        // Note: `fields.key` is not returned by old Companion versions.\n        // See https://github.com/transloadit/uppy/pull/5602\n        const key = fields?.key;\n        this.#setS3MultipartState(file, { key: key });\n        return {\n            ...result,\n            location: result.location ?? removeMetadataFromURL(url),\n            bucket: fields?.bucket,\n            key,\n        };\n    }\n    async uploadFile(file, chunks, signal) {\n        throwIfAborted(signal);\n        if (chunks.length === 1 && !chunks[0].shouldUseMultipart) {\n            return this.#nonMultipartUpload(file, chunks[0], signal);\n        }\n        const { uploadId, key } = await this.getUploadId(file, signal);\n        throwIfAborted(signal);\n        try {\n            const parts = await Promise.all(chunks.map((chunk, i) => this.uploadChunk(file, i + 1, chunk, signal)));\n            throwIfAborted(signal);\n            return await this.#sendCompletionRequest(this.#getFile(file), { key, uploadId, parts, signal }, signal).abortOn(signal);\n        }\n        catch (err) {\n            if (err?.cause !== pausingUploadReason && err?.name !== 'AbortError') {\n                // We purposefully don't wait for the promise and ignore its status,\n                // because we want the error `err` to bubble up ASAP to report it to the\n                // user. A failure to abort is not that big of a deal anyway.\n                this.abortFileUpload(file);\n            }\n            throw err;\n        }\n    }\n    restoreUploadFile(file, uploadIdAndKey) {\n        this.#cache.set(file.data, uploadIdAndKey);\n    }\n    async resumeUploadFile(file, chunks, signal) {\n        throwIfAborted(signal);\n        if (chunks.length === 1 &&\n            chunks[0] != null &&\n            !chunks[0].shouldUseMultipart) {\n            return this.#nonMultipartUpload(file, chunks[0], signal);\n        }\n        const { uploadId, key } = await this.getUploadId(file, signal);\n        throwIfAborted(signal);\n        const alreadyUploadedParts = await this.#listParts(this.#getFile(file), { uploadId, key, signal }, signal).abortOn(signal);\n        throwIfAborted(signal);\n        const parts = await Promise.all(chunks.map((chunk, i) => {\n            const partNumber = i + 1;\n            const alreadyUploadedInfo = alreadyUploadedParts.find(({ PartNumber }) => PartNumber === partNumber);\n            if (alreadyUploadedInfo == null) {\n                return this.uploadChunk(file, partNumber, chunk, signal);\n            }\n            // Already uploaded chunks are set to null. If we are restoring the upload, we need to mark it as already uploaded.\n            chunk?.setAsUploaded?.();\n            return { PartNumber: partNumber, ETag: alreadyUploadedInfo.ETag };\n        }));\n        throwIfAborted(signal);\n        return this.#sendCompletionRequest(this.#getFile(file), { key, uploadId, parts, signal }, signal).abortOn(signal);\n    }\n    async uploadChunk(file, partNumber, chunk, signal) {\n        throwIfAborted(signal);\n        const { uploadId, key } = await this.getUploadId(file, signal);\n        const signatureRetryIterator = this.#retryDelays.values();\n        const chunkRetryIterator = this.#retryDelays.values();\n        const shouldRetrySignature = () => {\n            const next = signatureRetryIterator.next();\n            if (next == null || next.done) {\n                return null;\n            }\n            return next.value;\n        };\n        for (;;) {\n            throwIfAborted(signal);\n            const chunkData = chunk.getData();\n            const { onProgress, onComplete } = chunk;\n            let signature;\n            try {\n                signature = await this.#fetchSignature(this.#getFile(file), {\n                    // Always defined for multipart uploads\n                    uploadId: uploadId,\n                    key,\n                    partNumber,\n                    body: chunkData,\n                    signal,\n                }).abortOn(signal);\n            }\n            catch (err) {\n                const timeout = shouldRetrySignature();\n                if (timeout == null || signal.aborted) {\n                    throw err;\n                }\n                await new Promise((resolve) => setTimeout(resolve, timeout));\n                continue;\n            }\n            throwIfAborted(signal);\n            try {\n                return {\n                    PartNumber: partNumber,\n                    ...(await this.#uploadPartBytes({\n                        signature,\n                        body: chunkData,\n                        size: chunkData.size,\n                        onProgress,\n                        onComplete,\n                        signal,\n                    }).abortOn(signal)),\n                };\n            }\n            catch (err) {\n                if (!(await this.#shouldRetry(err, chunkRetryIterator)))\n                    throw err;\n            }\n        }\n    }\n}\n", "import { RequestClient } from '@uppy/companion-client';\nimport { BasePlugin, EventManager, } from '@uppy/core';\nimport { createAbortError, filterFilesToEmitUploadStarted, filterNonFailedFiles, getAllowedMetaFields, RateLimitedQueue, } from '@uppy/utils';\nimport packageJson from '../package.json' with { type: 'json' };\nimport createSignedURL from './createSignedURL.js';\nimport { HTTPCommunicationQueue } from './HTTPCommunicationQueue.js';\nimport MultipartUploader from './MultipartUploader.js';\nimport { throwIfAborted } from './utils.js';\nfunction assertServerError(res) {\n    if (res?.error) {\n        const error = new Error(res.message);\n        Object.assign(error, res.error);\n        throw error;\n    }\n    return res;\n}\n/**\n * Computes the expiry time for a request signed with temporary credentials. If\n * no expiration was provided, or an invalid value (e.g. in the past) is\n * provided, undefined is returned. This function assumes the client clock is in\n * sync with the remote server, which is a requirement for the signature to be\n * validated for AWS anyway.\n */\nfunction getExpiry(credentials) {\n    const expirationDate = credentials.Expiration;\n    if (expirationDate) {\n        const timeUntilExpiry = Math.floor((new Date(expirationDate) - Date.now()) / 1000);\n        if (timeUntilExpiry > 9) {\n            return timeUntilExpiry;\n        }\n    }\n    return undefined;\n}\nfunction getAllowedMetadata({ meta, allowedMetaFields, querify = false, }) {\n    const metaFields = allowedMetaFields ?? Object.keys(meta);\n    if (!meta)\n        return {};\n    return Object.fromEntries(metaFields\n        .filter((key) => meta[key] != null)\n        .map((key) => {\n        const realKey = querify ? `metadata[${key}]` : key;\n        const value = String(meta[key]);\n        return [realKey, value];\n    }));\n}\nconst defaultOptions = {\n    allowedMetaFields: true,\n    limit: 6,\n    getTemporarySecurityCredentials: false,\n    shouldUseMultipart: ((file) => (file.size || 0) > 100 * 1024 * 1024),\n    retryDelays: [0, 1000, 3000, 5000],\n};\nexport default class AwsS3Multipart extends BasePlugin {\n    static VERSION = packageJson.version;\n    #companionCommunicationQueue;\n    #client;\n    requests;\n    uploaderEvents;\n    uploaders;\n    constructor(uppy, opts) {\n        super(uppy, {\n            ...defaultOptions,\n            uploadPartBytes: AwsS3Multipart.uploadPartBytes,\n            createMultipartUpload: null,\n            listParts: null,\n            abortMultipartUpload: null,\n            completeMultipartUpload: null,\n            signPart: null,\n            getUploadParameters: null,\n            ...opts,\n        });\n        // We need the `as any` here because of the dynamic default options.\n        this.type = 'uploader';\n        this.id = this.opts.id || 'AwsS3Multipart';\n        this.#setClient(opts);\n        const dynamicDefaultOptions = {\n            createMultipartUpload: this.createMultipartUpload,\n            listParts: this.listParts,\n            abortMultipartUpload: this.abortMultipartUpload,\n            completeMultipartUpload: this.completeMultipartUpload,\n            signPart: opts?.getTemporarySecurityCredentials\n                ? this.createSignedURL\n                : this.signPart,\n            getUploadParameters: opts?.getTemporarySecurityCredentials\n                ? this.createSignedURL\n                : this.getUploadParameters,\n        };\n        for (const key of Object.keys(dynamicDefaultOptions)) {\n            if (this.opts[key] == null) {\n                this.opts[key] =\n                    dynamicDefaultOptions[key].bind(this);\n            }\n        }\n        /**\n         * Simultaneous upload limiting is shared across all uploads with this plugin.\n         *\n         * @type {RateLimitedQueue}\n         */\n        this.requests =\n            this.opts.rateLimitedQueue ??\n                new RateLimitedQueue(this.opts.limit);\n        this.#companionCommunicationQueue = new HTTPCommunicationQueue(this.requests, this.opts, this.#setS3MultipartState, this.#getFile);\n        this.uploaders = Object.create(null);\n        this.uploaderEvents = Object.create(null);\n    }\n    [Symbol.for('uppy test: getClient')]() {\n        return this.#client;\n    }\n    #setClient(opts) {\n        if (opts == null ||\n            !('endpoint' in opts ||\n                'companionUrl' in opts ||\n                'headers' in opts ||\n                'companionHeaders' in opts ||\n                'cookiesRule' in opts ||\n                'companionCookiesRule' in opts))\n            return;\n        if ('companionUrl' in opts && !('endpoint' in opts)) {\n            this.uppy.log('`companionUrl` option has been removed in @uppy/aws-s3, use `endpoint` instead.', 'warning');\n        }\n        if ('companionHeaders' in opts && !('headers' in opts)) {\n            this.uppy.log('`companionHeaders` option has been removed in @uppy/aws-s3, use `headers` instead.', 'warning');\n        }\n        if ('companionCookiesRule' in opts && !('cookiesRule' in opts)) {\n            this.uppy.log('`companionCookiesRule` option has been removed in @uppy/aws-s3, use `cookiesRule` instead.', 'warning');\n        }\n        if ('endpoint' in opts) {\n            this.#client = new RequestClient(this.uppy, {\n                pluginId: this.id,\n                provider: 'AWS',\n                companionUrl: this.opts.endpoint,\n                companionHeaders: this.opts.headers,\n                companionCookiesRule: this.opts.cookiesRule,\n            });\n        }\n        else {\n            if ('headers' in opts) {\n                this.#setCompanionHeaders();\n            }\n            if ('cookiesRule' in opts) {\n                this.#client.opts.companionCookiesRule = opts.cookiesRule;\n            }\n        }\n    }\n    setOptions(newOptions) {\n        this.#companionCommunicationQueue.setOptions(newOptions);\n        super.setOptions(newOptions);\n        this.#setClient(newOptions);\n    }\n    /**\n     * Clean up all references for a file's upload: the MultipartUploader instance,\n     * any events related to the file, and the Companion WebSocket connection.\n     *\n     * Set `opts.abort` to tell S3 that the multipart upload is cancelled and must be removed.\n     * This should be done when the user cancels the upload, not when the upload is completed or errored.\n     */\n    resetUploaderReferences(fileID, opts) {\n        if (this.uploaders[fileID]) {\n            this.uploaders[fileID].abort({ really: opts?.abort || false });\n            this.uploaders[fileID] = null;\n        }\n        if (this.uploaderEvents[fileID]) {\n            this.uploaderEvents[fileID].remove();\n            this.uploaderEvents[fileID] = null;\n        }\n    }\n    #assertHost(method) {\n        if (!this.#client) {\n            throw new Error(`Expected a \\`endpoint\\` option containing a URL, or if you are not using Companion, a custom \\`${method}\\` implementation.`);\n        }\n    }\n    createMultipartUpload(file, signal) {\n        this.#assertHost('createMultipartUpload');\n        throwIfAborted(signal);\n        const allowedMetaFields = getAllowedMetaFields(this.opts.allowedMetaFields, file.meta);\n        const metadata = getAllowedMetadata({ meta: file.meta, allowedMetaFields });\n        return this.#client\n            .post('s3/multipart', {\n            filename: file.name,\n            type: file.type,\n            metadata,\n        }, { signal })\n            .then(assertServerError);\n    }\n    listParts(file, { key, uploadId, signal }, oldSignal) {\n        signal ??= oldSignal;\n        this.#assertHost('listParts');\n        throwIfAborted(signal);\n        const filename = encodeURIComponent(key);\n        return this.#client\n            .get(`s3/multipart/${encodeURIComponent(uploadId)}?key=${filename}`, { signal })\n            .then(assertServerError);\n    }\n    completeMultipartUpload(file, { key, uploadId, parts, signal }, oldSignal) {\n        signal ??= oldSignal;\n        this.#assertHost('completeMultipartUpload');\n        throwIfAborted(signal);\n        const filename = encodeURIComponent(key);\n        const uploadIdEnc = encodeURIComponent(uploadId);\n        return this.#client\n            .post(`s3/multipart/${uploadIdEnc}/complete?key=${filename}`, { parts: parts.map(({ ETag, PartNumber }) => ({ ETag, PartNumber })) }, { signal })\n            .then(assertServerError);\n    }\n    #cachedTemporaryCredentials;\n    async #getTemporarySecurityCredentials(options) {\n        throwIfAborted(options?.signal);\n        if (this.#cachedTemporaryCredentials == null) {\n            const { getTemporarySecurityCredentials } = this.opts;\n            // We do not await it just yet, so concurrent calls do not try to override it:\n            if (getTemporarySecurityCredentials === true) {\n                this.#assertHost('getTemporarySecurityCredentials');\n                this.#cachedTemporaryCredentials = this.#client\n                    .get('s3/sts', options)\n                    .then(assertServerError);\n            }\n            else {\n                this.#cachedTemporaryCredentials =\n                    getTemporarySecurityCredentials(options);\n            }\n            this.#cachedTemporaryCredentials = await this.#cachedTemporaryCredentials;\n            setTimeout(() => {\n                // At half the time left before expiration, we clear the cache. That's\n                // an arbitrary tradeoff to limit the number of requests made to the\n                // remote while limiting the risk of using an expired token in case the\n                // clocks are not exactly synced.\n                // The HTTP cache should be configured to ensure a client doesn't request\n                // more tokens than it needs, but this timeout provides a second layer of\n                // security in case the HTTP cache is disabled or misconfigured.\n                this.#cachedTemporaryCredentials = null;\n            }, (getExpiry(this.#cachedTemporaryCredentials.credentials) || 0) * 500);\n        }\n        return this.#cachedTemporaryCredentials;\n    }\n    async createSignedURL(file, options) {\n        const data = await this.#getTemporarySecurityCredentials(options);\n        const expires = getExpiry(data.credentials) || 604_800; // 604 800 is the max value accepted by AWS.\n        const { uploadId, key, partNumber } = options;\n        // Return an object in the correct shape.\n        return {\n            method: 'PUT',\n            expires,\n            fields: {},\n            url: `${await createSignedURL({\n                accountKey: data.credentials.AccessKeyId,\n                accountSecret: data.credentials.SecretAccessKey,\n                sessionToken: data.credentials.SessionToken,\n                expires,\n                bucketName: data.bucket,\n                Region: data.region,\n                Key: key ?? `${crypto.randomUUID()}-${file.name}`,\n                uploadId,\n                partNumber,\n            })}`,\n            // Provide content type header required by S3\n            headers: {\n                'Content-Type': file.type,\n            },\n        };\n    }\n    signPart(file, { uploadId, key, partNumber, signal }) {\n        this.#assertHost('signPart');\n        throwIfAborted(signal);\n        if (uploadId == null || key == null || partNumber == null) {\n            throw new Error('Cannot sign without a key, an uploadId, and a partNumber');\n        }\n        const filename = encodeURIComponent(key);\n        return this.#client\n            .get(`s3/multipart/${encodeURIComponent(uploadId)}/${partNumber}?key=${filename}`, { signal })\n            .then(assertServerError);\n    }\n    abortMultipartUpload(file, { key, uploadId, signal }) {\n        this.#assertHost('abortMultipartUpload');\n        const filename = encodeURIComponent(key);\n        const uploadIdEnc = encodeURIComponent(uploadId);\n        return this.#client\n            .delete(`s3/multipart/${uploadIdEnc}?key=${filename}`, undefined, {\n            signal,\n        })\n            .then(assertServerError);\n    }\n    getUploadParameters(file, options) {\n        this.#assertHost('getUploadParameters');\n        const { meta } = file;\n        const { type, name: filename } = meta;\n        const allowedMetaFields = getAllowedMetaFields(this.opts.allowedMetaFields, file.meta);\n        const metadata = getAllowedMetadata({\n            meta,\n            allowedMetaFields,\n            querify: true,\n        });\n        const query = new URLSearchParams({ filename, type, ...metadata });\n        return this.#client.get(`s3/params?${query}`, options);\n    }\n    static async uploadPartBytes({ signature: { url, expires, headers, method = 'PUT' }, body, size = body.size, onProgress, onComplete, signal, }) {\n        throwIfAborted(signal);\n        if (url == null) {\n            throw new Error('Cannot upload to an undefined URL');\n        }\n        return new Promise((resolve, reject) => {\n            const xhr = new XMLHttpRequest();\n            xhr.open(method, url, true);\n            if (headers) {\n                Object.keys(headers).forEach((key) => {\n                    xhr.setRequestHeader(key, headers[key]);\n                });\n            }\n            xhr.responseType = 'text';\n            if (typeof expires === 'number') {\n                xhr.timeout = expires * 1000;\n            }\n            function onabort() {\n                xhr.abort();\n            }\n            function cleanup() {\n                signal?.removeEventListener('abort', onabort);\n            }\n            signal?.addEventListener('abort', onabort);\n            xhr.upload.addEventListener('progress', (ev) => {\n                onProgress(ev);\n            });\n            xhr.addEventListener('abort', () => {\n                cleanup();\n                reject(createAbortError());\n            });\n            xhr.addEventListener('timeout', () => {\n                cleanup();\n                const error = new Error('Request has expired');\n                error.source = { status: 403 };\n                reject(error);\n            });\n            xhr.addEventListener('load', () => {\n                cleanup();\n                if (xhr.status === 403 &&\n                    xhr.responseText.includes('<Message>Request has expired</Message>')) {\n                    const error = new Error('Request has expired');\n                    error.source = xhr;\n                    reject(error);\n                    return;\n                }\n                if (xhr.status < 200 || xhr.status >= 300) {\n                    const error = new Error('Non 2xx');\n                    error.source = xhr;\n                    reject(error);\n                    return;\n                }\n                onProgress?.({ loaded: size, lengthComputable: true });\n                // https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getAllResponseHeaders#examples\n                const arr = xhr\n                    .getAllResponseHeaders()\n                    .trim()\n                    .split(/[\\r\\n]+/);\n                // @ts-expect-error null is allowed to avoid inherited properties\n                const headersMap = { __proto__: null };\n                for (const line of arr) {\n                    const parts = line.split(': ');\n                    const header = parts.shift();\n                    const value = parts.join(': ');\n                    headersMap[header] = value;\n                }\n                const { etag, location } = headersMap;\n                // More info bucket settings when this is not present:\n                // https://github.com/transloadit/uppy/issues/5388#issuecomment-2464885562\n                if (method.toUpperCase() === 'POST' && location == null) {\n                    // Not being able to read the Location header is not a fatal error.\n                    console.error('@uppy/aws-s3: Could not read the Location header. This likely means CORS is not configured correctly on the S3 Bucket. See https://uppy.io/docs/aws-s3/#setting-up-your-s3-bucket');\n                }\n                if (etag == null) {\n                    console.error('@uppy/aws-s3: Could not read the ETag header. This likely means CORS is not configured correctly on the S3 Bucket. See https://uppy.io/docs/aws-s3/#setting-up-your-s3-bucket');\n                    return;\n                }\n                onComplete?.(etag);\n                resolve({\n                    ...headersMap,\n                    ETag: etag, // keep capitalised ETag for backwards compatiblity\n                });\n            });\n            xhr.addEventListener('error', (ev) => {\n                cleanup();\n                const error = new Error('Unknown error');\n                error.source = ev.target;\n                reject(error);\n            });\n            xhr.send(body);\n        });\n    }\n    #setS3MultipartState = (file, { key, uploadId }) => {\n        const cFile = this.uppy.getFile(file.id);\n        if (cFile == null) {\n            // file was removed from store\n            return;\n        }\n        this.uppy.setFileState(file.id, {\n            s3Multipart: {\n                ...cFile.s3Multipart,\n                key,\n                uploadId,\n            },\n        });\n    };\n    #getFile = (file) => {\n        return this.uppy.getFile(file.id) || file;\n    };\n    #uploadLocalFile(file) {\n        return new Promise((resolve, reject) => {\n            const onProgress = (bytesUploaded, bytesTotal) => {\n                const latestFile = this.uppy.getFile(file.id);\n                this.uppy.emit('upload-progress', latestFile, {\n                    uploadStarted: latestFile.progress.uploadStarted ?? 0,\n                    bytesUploaded,\n                    bytesTotal,\n                });\n            };\n            const onError = (err) => {\n                this.uppy.log(err);\n                this.uppy.emit('upload-error', file, err);\n                this.resetUploaderReferences(file.id);\n                reject(err);\n            };\n            const onSuccess = (result) => {\n                const uploadResp = {\n                    body: {\n                        ...result,\n                    },\n                    status: 200,\n                    uploadURL: result.location,\n                };\n                this.resetUploaderReferences(file.id);\n                this.uppy.emit('upload-success', this.#getFile(file), uploadResp);\n                if (result.location) {\n                    this.uppy.log(`Download ${file.name} from ${result.location}`);\n                }\n                resolve(undefined);\n            };\n            const upload = new MultipartUploader(file.data, {\n                // .bind to pass the file object to each handler.\n                companionComm: this.#companionCommunicationQueue,\n                log: (...args) => this.uppy.log(...args),\n                getChunkSize: this.opts.getChunkSize\n                    ? this.opts.getChunkSize.bind(this)\n                    : undefined,\n                onProgress,\n                onError,\n                onSuccess,\n                onPartComplete: (part) => {\n                    this.uppy.emit('s3-multipart:part-uploaded', this.#getFile(file), part);\n                },\n                file,\n                shouldUseMultipart: this.opts.shouldUseMultipart,\n                ...file.s3Multipart,\n            });\n            this.uploaders[file.id] = upload;\n            const eventManager = new EventManager(this.uppy);\n            this.uploaderEvents[file.id] = eventManager;\n            eventManager.onFileRemove(file.id, (removed) => {\n                upload.abort();\n                this.resetUploaderReferences(file.id, { abort: true });\n                resolve(`upload ${removed} was removed`);\n            });\n            eventManager.onCancelAll(file.id, () => {\n                upload.abort();\n                this.resetUploaderReferences(file.id, { abort: true });\n                resolve(`upload ${file.id} was canceled`);\n            });\n            eventManager.onFilePause(file.id, (isPaused) => {\n                if (isPaused) {\n                    upload.pause();\n                }\n                else {\n                    upload.start();\n                }\n            });\n            eventManager.onPauseAll(file.id, () => {\n                upload.pause();\n            });\n            eventManager.onResumeAll(file.id, () => {\n                upload.start();\n            });\n            upload.start();\n        });\n    }\n    #getCompanionClientArgs(file) {\n        return {\n            ...file.remote?.body,\n            protocol: 's3-multipart',\n            size: file.data.size,\n            metadata: file.meta,\n        };\n    }\n    #upload = async (fileIDs) => {\n        if (fileIDs.length === 0)\n            return undefined;\n        const files = this.uppy.getFilesByIds(fileIDs);\n        const filesFiltered = filterNonFailedFiles(files);\n        const filesToEmit = filterFilesToEmitUploadStarted(filesFiltered);\n        this.uppy.emit('upload-start', filesToEmit);\n        const promises = filesFiltered.map((file) => {\n            if (file.isRemote) {\n                const getQueue = () => this.requests;\n                this.#setResumableUploadsCapability(false);\n                const controller = new AbortController();\n                const removedHandler = (removedFile) => {\n                    if (removedFile.id === file.id)\n                        controller.abort();\n                };\n                this.uppy.on('file-removed', removedHandler);\n                const uploadPromise = this.uppy\n                    .getRequestClientForFile(file)\n                    .uploadRemoteFile(file, this.#getCompanionClientArgs(file), {\n                    signal: controller.signal,\n                    getQueue,\n                });\n                this.requests.wrapSyncFunction(() => {\n                    this.uppy.off('file-removed', removedHandler);\n                }, { priority: -1 })();\n                return uploadPromise;\n            }\n            return this.#uploadLocalFile(file);\n        });\n        const upload = await Promise.allSettled(promises);\n        // After the upload is done, another upload may happen with only local files.\n        // We reset the capability so that the next upload can use resumable uploads.\n        this.#setResumableUploadsCapability(true);\n        return upload;\n    };\n    #setCompanionHeaders = () => {\n        this.#client?.setCompanionHeaders(this.opts.headers);\n    };\n    #setResumableUploadsCapability = (boolean) => {\n        const { capabilities } = this.uppy.getState();\n        this.uppy.setState({\n            capabilities: {\n                ...capabilities,\n                resumableUploads: boolean,\n            },\n        });\n    };\n    #resetResumableCapability = () => {\n        this.#setResumableUploadsCapability(true);\n    };\n    install() {\n        this.#setResumableUploadsCapability(true);\n        this.uppy.addPreProcessor(this.#setCompanionHeaders);\n        this.uppy.addUploader(this.#upload);\n        this.uppy.on('cancel-all', this.#resetResumableCapability);\n    }\n    uninstall() {\n        this.uppy.removePreProcessor(this.#setCompanionHeaders);\n        this.uppy.removeUploader(this.#upload);\n        this.uppy.off('cancel-all', this.#resetResumableCapability);\n    }\n}\n"],
  "mappings": "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",
  "names": ["original", "require_retry", "retry", "package_default", "AbortController", "key", "defaultOptions", "package_default", "location"]
}
